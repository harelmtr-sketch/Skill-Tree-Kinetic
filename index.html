<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Tree Node + Edge Picker</title>
    <style>
      body {
        margin: 0;
        background: #111;
        display: grid;
        place-items: center;
        height: 100vh;
        overflow: hidden;
      }

      #wrap{
        position: relative;
        width: 92vw;
        height: 92vh;
        overflow: hidden;
        background: #000;
        border: 1px solid #222;
        border-radius: 14px;
        touch-action: none;
      }

      img{
        position: absolute;
        left: 0;
        top: 0;
        transform-origin: 0 0;
        user-select: none;
        -webkit-user-drag: none;
        pointer-events: none;
        filter: brightness(0.95) contrast(1.05);
      }

      canvas{
        position: absolute;
        left: 0;
        top: 0;
        transform-origin: 0 0;
      }

      #status {
        position: fixed;
        top: 10px;
        left: 10px;
        background: rgba(0,0,0,0.85);
        color: #0f0;
        padding: 8px 10px;
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        z-index: 9999;
        border-radius: 10px;
        border: 1px solid #222;
        max-width: 70vw;
        white-space: pre-wrap;
      }

      #controls {
        position: fixed;
        top: 55px;
        left: 10px;
        z-index: 9999;
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
      }
      #controls button {
        padding: 8px 10px;
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
        font-weight: 650;
        border-radius: 10px;
        border: 1px solid #333;
        background: #111;
        color: #fff;
        cursor: pointer;
      }
      #controls button:hover { background: #222; }
      #btnClear { background: #400; border-color: #600; }
      #btnClear:hover { background: #600; }
      #btnViewer { background: #113; border-color: #225; }
      #btnViewer:hover { background: #225; }
    </style>
  </head>

  <body>
    <div id="status">loading…</div>

    <div id="controls">
      <button id="btnLoadGraph">Load Existing Tree</button>
      <button id="btnNodes">Node Mode</button>
      <button id="btnEdges">Edge Mode</button>
      <button id="btnUndo">Undo</button>
      <button id="btnDownload">Download Nodes+Edges</button>
      <button id="btnDownloadGraph">Download skill_tree_graph.json</button>
      <button id="btnClearEdges">Clear Edges Only</button>
      <button id="btnClear">Clear All</button>
      <button id="btnViewer">Open Viewer</button>
    </div>

    <div id="wrap">
      <img id="bg" src="tree.jpg" />
      <canvas id="c"></canvas>
    </div>

    <script>
      // ========= CONFIG =========
      const IMG_FILENAME = "tree.jpg";

      // Selection radius in IMAGE PIXELS (not screen pixels)
      const PICK_RADIUS = 60;

      const MIN_ZOOM = 0.15;
      const MAX_ZOOM = 12;

      // ========= STATE =========
      const statusEl = document.getElementById("status");
      const wrap = document.getElementById("wrap");
      const img = document.getElementById("bg");
      const canvas = document.getElementById("c");
      const ctx = canvas.getContext("2d");

      img.src = IMG_FILENAME;

      let IMAGE_W = 0;
      let IMAGE_H = 0;

      const nodes = [];
      const edges = [];

      // When true, node placement/count are preserved and only edges are edited.
      let preserveNodes = false;

      let mode = "nodes"; // "nodes" or "edges"
      let selectedNodeId = null;
      let hoverNodeId = null;

      // camera transform (screen px)
      let scale = 1;
      let offsetX = 0;
      let offsetY = 0;

      // drag tracking
      let dragging = false;
      let lastX = 0, lastY = 0;
      let didDrag = false;

      // ========= UTILS =========
      function setStatus(msg, isError = false) {
        statusEl.textContent = msg;
        statusEl.style.color = isError ? "#f44" : "#0f0";
      }

      function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

      function applyTransform() {
        const t = `translate(${offsetX}px, ${offsetY}px) scale(${scale})`;
        img.style.transform = t;
        canvas.style.transform = t;
      }

      function fitInitial() {
        const vw = wrap.clientWidth;
        const vh = wrap.clientHeight;
        const sx = vw / IMAGE_W;
        const sy = vh / IMAGE_H;
        scale = Math.min(sx, sy) * 0.98;
        offsetX = (vw - IMAGE_W * scale) / 2;
        offsetY = (vh - IMAGE_H * scale) / 2;
        applyTransform();
      }

      // Convert pointer event to image pixel coords
      function eventToImageXY(e) {
        const rect = wrap.getBoundingClientRect();
        const sx = e.clientX - rect.left;
        const sy = e.clientY - rect.top;

        const x = (sx - offsetX) / scale;
        const y = (sy - offsetY) / scale;

        return { x: Math.round(x), y: Math.round(y) };
      }

      function findNearestNodeId(wx, wy, maxDist = PICK_RADIUS) {
        let best = null;
        let bestD2 = maxDist * maxDist;
        for (const n of nodes) {
          const dx = n.x - wx;
          const dy = n.y - wy;
          const d2 = dx * dx + dy * dy;
          if (d2 < bestD2) {
            bestD2 = d2;
            best = n.id;
          }
        }
        return best;
      }

      function downloadJSON(filename, data) {
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = filename;
        a.click();
        URL.revokeObjectURL(url);
      }

      function setMode(newMode) {
        mode = newMode;
        selectedNodeId = null;
        hoverNodeId = null;
        draw();
        setStatus(`mode=${mode} | nodes=${nodes.length} edges=${edges.length} | preserveNodes=${preserveNodes}`);
      }

      function normalizeAndPushGraph(graph) {
        const rawNodes = Array.isArray(graph.nodes) ? graph.nodes : [];
        const rawEdges = Array.isArray(graph.edges) ? graph.edges : [];

        nodes.length = 0;
        edges.length = 0;

        for (const n of rawNodes) {
          if (n == null || n.id == null || Number.isNaN(Number(n.x)) || Number.isNaN(Number(n.y))) continue;
          nodes.push({ id: String(n.id), x: Math.round(Number(n.x)), y: Math.round(Number(n.y)) });
        }

        const nodeIdSet = new Set(nodes.map(n => n.id));
        for (const e of rawEdges) {
          if (!e || e.from == null || e.to == null) continue;
          const from = String(e.from);
          const to = String(e.to);
          if (!nodeIdSet.has(from) || !nodeIdSet.has(to)) continue;
          if (from === to) continue;
          edges.push({ from, to });
        }

        selectedNodeId = null;
        hoverNodeId = null;
      }

      async function loadExistingTree() {
        try {
          setStatus("loading skill_tree_graph.json …");
          const graph = await fetch("skill_tree_graph.json", { cache: "no-store" }).then(r => {
            if (!r.ok) throw new Error("skill_tree_graph.json not found");
            return r.json();
          });

          normalizeAndPushGraph(graph);
          preserveNodes = true;
          mode = "edges";
          draw();
          setStatus(
            `loaded skill_tree_graph.json\nmode=${mode} | preserveNodes=${preserveNodes}\n` +
            `nodes=${nodes.length} edges=${edges.length}\n` +
            `you can now reconnect edges and download a new skill_tree_graph.json`
          );
        } catch (err) {
          console.error(err);
          setStatus(`failed to load skill_tree_graph.json: ${err.message}`, true);
        }
      }

      // ========= DRAW =========
      function draw() {
        if (!IMAGE_W || !IMAGE_H) return;

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // edges
        ctx.lineWidth = 5;
        ctx.lineCap = "round";
        ctx.lineJoin = "round";
        ctx.strokeStyle = "rgba(255,0,0,0.55)";
        for (const e of edges) {
          const a = nodes.find(n => n.id === e.from);
          const b = nodes.find(n => n.id === e.to);
          if (!a || !b) continue;

          ctx.beginPath();
          ctx.moveTo(a.x, a.y);
          ctx.lineTo(b.x, b.y);
          ctx.stroke();
        }

        // nodes
        for (const n of nodes) {
          const isSelected = n.id === selectedNodeId;
          const isHover = n.id === hoverNodeId;

          ctx.beginPath();
          ctx.arc(n.x, n.y, 18, 0, Math.PI * 2);

          ctx.strokeStyle = isSelected
            ? "rgba(255,255,0,0.95)"
            : isHover
            ? "rgba(0,200,255,0.95)"
            : "rgba(255,0,0,0.9)";

          ctx.lineWidth = 3;
          ctx.stroke();

          ctx.beginPath();
          ctx.arc(n.x, n.y, 4, 0, Math.PI * 2);
          ctx.fillStyle = isSelected
            ? "rgba(255,255,0,0.95)"
            : isHover
            ? "rgba(0,200,255,0.95)"
            : "rgba(255,0,0,0.9)";
          ctx.fill();
        }
      }

      // ========= EDGE HOVER =========
      wrap.addEventListener("mousemove", (e) => {
        if (mode !== "edges") return;
        if (dragging) return;
        if (!IMAGE_W) return;

        const { x: wx, y: wy } = eventToImageXY(e);
        hoverNodeId = findNearestNodeId(wx, wy, PICK_RADIUS);
        draw();
      });

      // ========= CLICK (add node / add edge) =========
      wrap.addEventListener("click", (e) => {
        if (!IMAGE_W) return;
        if (didDrag) return;

        const { x: wx, y: wy } = eventToImageXY(e);

        // ignore clicks outside image bounds
        if (wx < 0 || wy < 0 || wx > IMAGE_W || wy > IMAGE_H) {
          setStatus("clicked outside image bounds", true);
          return;
        }

        if (mode === "nodes") {
          if (preserveNodes) {
            setStatus("node placement is locked (preserveNodes=true). Use Edge Mode to reconnect.", true);
            return;
          }

          const id = `node_${String(nodes.length + 1).padStart(3, "0")}`;
          nodes.push({ id, x: wx, y: wy });
          selectedNodeId = null;
          hoverNodeId = null;
          draw();
          setStatus(`added ${id}: (${wx}, ${wy})\nnodes=${nodes.length} edges=${edges.length}`);
          return;
        }

        // edge mode
        if (nodes.length === 0) {
          setStatus("edge mode: add nodes first", true);
          return;
        }

        const nearest = findNearestNodeId(wx, wy, PICK_RADIUS);
        if (!nearest) {
          setStatus(`edge mode: no node nearby.\nTip: hover should turn node cyan. If none turns cyan, you’re not near a node.`, true);
          return;
        }

        if (!selectedNodeId) {
          selectedNodeId = nearest;
          draw();
          setStatus(`edge mode: selected ${selectedNodeId}\nnow click the node it connects to`);
        } else {
          const from = selectedNodeId;
          const to = nearest;

          if (from !== to) {
            const exists = edges.some(e => e.from === from && e.to === to);
            if (exists) {
              setStatus(`edge already exists: ${from} -> ${to}`, true);
            } else {
              edges.push({ from, to });
              setStatus(`added edge: ${from} -> ${to}\nedges=${edges.length}`);
            }
          } else {
            setStatus("same node clicked. edge not added.", true);
          }

          selectedNodeId = null;
          draw();
        }
      });

      // ========= ZOOM (wheel) =========
      wrap.addEventListener("wheel", (e) => {
        e.preventDefault();
        if (!IMAGE_W) return;

        const rect = wrap.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;

        const zoomIntensity = 0.0015;
        const delta = -e.deltaY;
        const factor = Math.exp(delta * zoomIntensity);

        const newScale = clamp(scale * factor, MIN_ZOOM, MAX_ZOOM);

        // keep point under cursor stable
        const ix = (mouseX - offsetX) / scale;
        const iy = (mouseY - offsetY) / scale;

        scale = newScale;
        offsetX = mouseX - ix * scale;
        offsetY = mouseY - iy * scale;

        applyTransform();
      }, { passive: false });

      // ========= PAN (drag) =========
      wrap.addEventListener("mousedown", (e) => {
        dragging = true;
        didDrag = false;
        lastX = e.clientX;
        lastY = e.clientY;
      });

      window.addEventListener("mousemove", (e) => {
        if (!dragging) return;
        const dx = e.clientX - lastX;
        const dy = e.clientY - lastY;
        lastX = e.clientX;
        lastY = e.clientY;

        if (Math.abs(dx) + Math.abs(dy) > 8) didDrag = true;

        offsetX += dx;
        offsetY += dy;
        applyTransform();
      });

      window.addEventListener("mouseup", () => {
        dragging = false;
      });

      // ========= BUTTONS =========
      document.getElementById("btnNodes").onclick = () => setMode("nodes");
      document.getElementById("btnEdges").onclick = () => setMode("edges");
      document.getElementById("btnLoadGraph").onclick = () => loadExistingTree();

      document.getElementById("btnUndo").onclick = () => {
        if (mode === "nodes" && nodes.length > 0) {
          const removed = nodes.pop();

          // Also remove any edges that referenced that node
          for (let i = edges.length - 1; i >= 0; i--) {
            if (edges[i].from === removed.id || edges[i].to === removed.id) edges.splice(i, 1);
          }

          selectedNodeId = null;
          hoverNodeId = null;
          draw();
          setStatus(`undo node: ${removed.id}\nnodes=${nodes.length} edges=${edges.length}`);
        } else if (mode === "edges" && edges.length > 0) {
          const removed = edges.pop();
          selectedNodeId = null;
          hoverNodeId = null;
          draw();
          setStatus(`undo edge: ${removed.from} -> ${removed.to}\nedges=${edges.length}`);
        } else {
          setStatus("nothing to undo", true);
        }
      };

      document.getElementById("btnDownload").onclick = () => {
        downloadJSON("nodes.json", { imageWidth: IMAGE_W, imageHeight: IMAGE_H, nodes });
        downloadJSON("edges.json", { edges });
        setStatus("downloaded nodes.json + edges.json");
      };

      document.getElementById("btnDownloadGraph").onclick = () => {
        downloadJSON("skill_tree_graph.json", {
          nodes: nodes.map(n => ({ id: n.id, x: n.x, y: n.y })),
          edges: edges.map(e => ({ from: e.from, to: e.to }))
        });
        setStatus("downloaded skill_tree_graph.json (replace your repo file with this to persist)");
      };

      document.getElementById("btnClearEdges").onclick = () => {
        if (!confirm("Clear all edges only? (nodes stay as-is)")) return;
        edges.length = 0;
        selectedNodeId = null;
        hoverNodeId = null;
        draw();
        setStatus(`cleared edges only\nnodes=${nodes.length} edges=${edges.length}`);
      };

      document.getElementById("btnClear").onclick = () => {
        if (!confirm("Clear all nodes and edges?")) return;
        nodes.length = 0;
        edges.length = 0;
        preserveNodes = false;
        selectedNodeId = null;
        hoverNodeId = null;
        draw();
        setStatus("cleared everything");
      };

      document.getElementById("btnViewer").onclick = () => {
        window.open("viewer.html", "_blank");
      };

      // ========= IMAGE LOAD =========
      img.onload = () => {
        IMAGE_W = img.naturalWidth;
        IMAGE_H = img.naturalHeight;

        canvas.width = IMAGE_W;
        canvas.height = IMAGE_H;

        img.width = IMAGE_W;
        img.height = IMAGE_H;

        fitInitial();
        applyTransform();
        draw();

        setStatus(`image loaded (${IMAGE_W}x${IMAGE_H})\nmode=${mode} nodes=${nodes.length} edges=${edges.length}`);

        // Auto-load if graph already exists so you can reconnect once and re-export.
        loadExistingTree();
      };

      img.onerror = () => setStatus(`IMAGE FAILED TO LOAD: "${IMG_FILENAME}" (check filename)`, true);

      window.addEventListener("resize", () => {
        if (!IMAGE_W) return;
        fitInitial();
        applyTransform();
      });
    </script>
  </body>
</html>
